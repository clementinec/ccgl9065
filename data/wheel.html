<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Papers Chord Diagram</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 30px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        
        .chart-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        .chord-group {
            font-size: 11px;
            font-weight: 600;
        }
        
        .chord-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 250px;
            z-index: 1000;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .stats {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .stats h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            font-size: 14px;
        }
        
        .stat-label {
            font-weight: 600;
            color: #34495e;
        }
        
        .paper-name {
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- <h1>Research Papers Field Connections</h1> -->
        
        <div class="chart-container">
            <svg id="chord-diagram" width="800" height="800"></svg>
        </div>
        
        <div class="chord-tooltip" id="tooltip"></div>
        
        <div class="legend" id="legend"></div>
        
        <div class="stats">
            <h3>Dataset Summary</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Total Papers:</span> 8
                </div>
                <div class="stat-item">
                    <span class="stat-label">Unique Fields:</span> 7
                </div>
                <div class="stat-item">
                    <span class="stat-label">Most Connected:</span> Thermal Comfort Modeling (4 connections)
                </div>
                <div class="stat-item">
                    <span class="stat-label">Average Effort:</span> 7.3
                </div>
            </div>
        </div>
    </div>

    <script>
        // Research papers data - just keep adding to this list with new stuffs.. 
        const papers = [
            {id: 1, name: "CO-SIM", field1: "Building Simulation", field2: "Thermal Comfort Modeling", effort: 8.5, timeFinished: 1},
            {id: 2, name: "PINN-VAE", field1: "Thermal Comfort Modeling", field2: "Physics-Informed Neural Network", effort: 7.5, timeFinished: 5},
            {id: 3, name: "MET-Sweep", field1: "Building Simulation", field2: "Thermal Comfort Modeling", effort: 8.0, timeFinished: 3},
            {id: 4, name: "ThermSAM", field1: "Computer Vision", field2: "Energy Predictive Analytics", effort: 7.0, timeFinished: 6},
            {id: 5, name: "WetMarket", field1: "Carbon Dioxide Sensing", field2: "Building Simulation", effort: 7.0, timeFinished: 2},
            {id: 6, name: "GlobalSensitivity", field1: "Thermal Comfort Modeling", field2: "AutoML", effort: 7.5, timeFinished: 3},
            {id: 7, name: "RSER", field1: "Thermal Comfort Modeling", field2: "AutoML", effort: 6.5, timeFinished: 7},
            {id: 8, name: "PINN", field1: "Thermal Comfort Modeling", field2: "Physics-Informed Neural Network", effort: 6.5, timeFinished: 4},
            {id: 9, name: "ICML-Sense", field1: "Thermal Comfort Modeling", field2: "AutoML", effort: 3.5, timeFinished: 2},
            {id: 10, name: "ICML-ThermalSAM", field1: "Computer Vision", field2: "Energy Predictive Analytics", effort: 4.5, timeFinished: 2},
            {id: 11, name: "IBPC-WetMarket", field1: "Carbon Dioxide Sensing", field2: "Thermal Comfort Modeling", effort: 3.5, timeFinished: 12},
            {id: 12, name: "IBPC-LLM", field1: "Large Language Model", field2: "Energy Predictive Analytics", effort: 3.5, timeFinished: 12},
        ];

        // Extract unique fields
        const allFields = [...new Set([...papers.map(p => p.field1), ...papers.map(p => p.field2)])];
        const fieldIndex = {};
        allFields.forEach((field, i) => fieldIndex[field] = i);

        // Create matrix where each paper gets its own connection (no blending)
        // We'll create "virtual" nodes for each paper connection
        const connections = [];
        const connectionPapers = {};
        
        papers.forEach((paper, paperIndex) => {
            const idx1 = fieldIndex[paper.field1];
            const idx2 = fieldIndex[paper.field2];
            
            connections.push({
                source: idx1,
                target: idx2,
                paper: paper,
                id: paperIndex
            });
            
            // Store paper info for tooltips
            const key1 = `${idx1}-${idx2}-${paperIndex}`;
            const key2 = `${idx2}-${idx1}-${paperIndex}`;
            
            connectionPapers[key1] = [paper];
            connectionPapers[key2] = [paper];
        });

        // Create matrix with separate entries for each paper
        const matrix = Array(allFields.length).fill().map(() => Array(allFields.length).fill(0));
        
        connections.forEach(conn => {
            // Add small increment for each individual paper
            matrix[conn.source][conn.target] += 0.5;
            matrix[conn.target][conn.source] += 0.5;
        });

        // Set up SVG
        const svg = d3.select("#chord-diagram");
        const width = 800;
        const height =800;
        const outerRadius = Math.min(width, height) * 0.32;
        const innerRadius = outerRadius - 20;

        const g = svg.append("g")
            .attr("transform", `translate(${width/2},${height/2})`);

        // Add slow rotation using D3 transitions
        function startRotation() {
            g.transition()
                .duration(300000) // 120 seconds = 2 minutes
                .ease(d3.easeLinear)
                .attrTween("transform", function() {
                    return d3.interpolateString(
                        `translate(${width/2},${height/2}) rotate(0)`,
                        `translate(${width/2},${height/2}) rotate(360)`
                    );
                })
                .on("end", function() {
                    // Reset and start again
                    g.attr("transform", `translate(${width/2},${height/2}) rotate(0)`);
                    startRotation();
                });
        }
        
        // Start rotation immediately
        startRotation();

        // Color scale - try different schemes by changing the line below
        const colors = d3.scaleOrdinal()
            .domain(allFields)
            .range(d3.schemeSet2); // Changed to Category10

        // Create chord layout
        const chord = d3.chord()
            .padAngle(0.05)
            .sortSubgroups(d3.descending);

        const arc = d3.arc()
            .innerRadius(innerRadius)
            .outerRadius(outerRadius);

        const ribbon = d3.ribbon()
            .radius(innerRadius);

        const chords = chord(matrix);

        // Tooltip
        const tooltip = d3.select("#tooltip");

        // Draw groups (the arcs)
        const group = g.append("g")
            .selectAll("g")
            .data(chords.groups)
            .enter().append("g");

        group.append("path")
            .style("fill", d => colors(allFields[d.index]))
            .style("stroke", d => d3.rgb(colors(allFields[d.index])).darker())
            .attr("d", arc)
            .on("mouseover", function(event, d) {
                const field = allFields[d.index];
                const connections = papers.filter(p => p.field1 === field || p.field2 === field).length;
                const relatedPapers = papers.filter(p => p.field1 === field || p.field2 === field)
                    .map(p => p.name).join(", ");
                
                tooltip
                    .style("opacity", 1)
                    .html(`<strong>${field}</strong><br/>Connections: ${connections}<br/>Papers: ${relatedPapers}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px");
            })
            .on("mouseout", () => {
                tooltip.style("opacity", 0);
            });

        // Add labels with more space
        group.append("text")
            .each(d => { d.angle = (d.startAngle + d.endAngle) / 2; })
            .attr("dy", ".35em")
            .attr("transform", d => `
                rotate(${(d.angle * 180 / Math.PI - 90)})
                translate(${outerRadius + 25})
                ${d.angle > Math.PI ? "rotate(180)" : ""}
            `)
            .style("text-anchor", d => d.angle > Math.PI ? "end" : "start")
            .style("font-size", "12px")
            .style("font-weight", "600")
            .style("fill", "#2c3e50")
            .text(d => allFields[d.index]); // Show full field names

        // Draw ribbons with individual paper identification
        g.append("g")
            .selectAll("path")
            .data(chords)
            .enter().append("path")
            .attr("d", ribbon)
            .style("fill", d => colors(allFields[d.source.index]))
            .style("opacity", 0.7)
            .style("stroke", d => d3.rgb(colors(allFields[d.source.index])).darker())
            .style("stroke-width", "1px")
            .each(function(d) {
                // Try to identify which paper this chord represents
                const sourceIdx = d.source.index;
                const targetIdx = d.target.index;
                const relatedPapers = papers.filter(p => 
                    (fieldIndex[p.field1] === sourceIdx && fieldIndex[p.field2] === targetIdx) ||
                    (fieldIndex[p.field1] === targetIdx && fieldIndex[p.field2] === sourceIdx)
                );
                d.papers = relatedPapers;
            })
            .on("mouseover", function(event, d) {
                const sourceField = allFields[d.source.index];
                const targetField = allFields[d.target.index];
                
                if (d.papers && d.papers.length > 0) {
                    let tooltipContent = `<strong>${sourceField}</strong> â†” <strong>${targetField}</strong><br/>`;
                    
                    if (d.papers.length === 1) {
                        const paper = d.papers[0];
                        tooltipContent += `Paper: <span class="paper-name">${paper.name}</span><br/>Effort: ${paper.effort}`;
                    } else {
                        const paperNames = d.papers.map(p => `<span class="paper-name">${p.name}</span>`).join(", ");
                        const totalEffort = d.papers.reduce((sum, p) => sum + p.effort, 0).toFixed(1);
                        tooltipContent += `Papers: ${paperNames}<br/>Total Effort: ${totalEffort}`;
                    }
                    
                    tooltip
                        .style("opacity", 1)
                        .html(tooltipContent)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                }

                d3.select(this).style("opacity", 0.9);
            })
            .on("mouseout", function() {
                tooltip.style("opacity", 0);
                d3.select(this).style("opacity", 0.7);
            });

        // Create legend
        const legend = d3.select("#legend");
        allFields.forEach(field => {
            const legendItem = legend.append("div")
                .attr("class", "legend-item");
            
            legendItem.append("div")
                .attr("class", "legend-color")
                .style("background-color", colors(field));
            
            legendItem.append("span")
                .text(field.length > 25 ? field.substring(0, 22) + "..." : field);
        });

        // Update stats with correct counts
        const connectionCounts = {};
        allFields.forEach(field => {
            connectionCounts[field] = papers.filter(p => p.field1 === field || p.field2 === field).length;
        });
        
        const mostConnected = Object.entries(connectionCounts).reduce((a, b) => connectionCounts[a[0]] > connectionCounts[b[0]] ? a : b);
        document.querySelector('.stats-grid .stat-item:nth-child(3) .stat-label').nextSibling.textContent = ` ${mostConnected[0]} (${mostConnected[1]} connections)`;
    </script>
</body>
</html>